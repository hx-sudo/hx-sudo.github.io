<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas</title>

    <!-- å¼•å…¥è‰ºæœ¯å­—ä½“ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">

    <!-- MediaPipe Global Scripts -->
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --gold: #FFD700;
            --red: #8a0a0a;
            --bg-gradient: radial-gradient(circle at 50% 30%, #2c466b 0%, #0c101c 100%);
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-gradient);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            color: white;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* åœ£è¯å¿«ä¹å¤§å­— */
        #merry-christmas {
            position: absolute;
            top: 5%;
            left: 0;
            width: 100%;
            text-align: center;
            font-family: 'Great Vibes', cursive;
            font-size: 6rem;
            font-weight: normal;
            color: transparent;
            background: linear-gradient(to bottom, #fff 20%, var(--gold) 80%);
            -webkit-background-clip: text;
            background-clip: text;
            letter-spacing: 5px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.4), 0 0 60px rgba(255, 0, 0, 0.2);
            z-index: 5;
            pointer-events: none;
            opacity: 0.95;
            transform: rotate(-2deg);
        }

        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        #ui-layer.hidden { opacity: 0; pointer-events: none; }
        #merry-christmas.hidden { opacity: 0; }

        /* å·¦ä¾§å¤´éƒ¨ */
        .header {
            position: absolute;
            top: 25%;
            left: 50px;
            text-align: left;
            z-index: 20;
            pointer-events: auto;
        }

        /* æ ‡é¢˜æ ·å¼ */
        h1 {
            font-weight: 300;
            letter-spacing: 8px;
            margin: 0 0 25px 0;
            color: var(--gold);
            font-size: 2rem;
            text-transform: uppercase;
            display: block;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.6);
            border-left: 4px solid var(--gold);
            padding-left: 20px;
        }

        /* çŠ¶æ€æ  */
        .status-bar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: flex-start;
            margin-top: 0;
        }

        .status-badge {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 30px;
            border-radius: 4px;
            font-size: 1rem;
            color: #aaa;
            transition: all 0.4s;
            width: 140px;
            text-align: center;
            letter-spacing: 2px;
        }

        .status-badge.active {
            color: #fff;
            background: rgba(212, 175, 55, 0.2);
            border-color: var(--gold);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            font-weight: bold;
            transform: translateX(15px);
            border-left: 3px solid #fff;
        }

        /* æ‘„åƒå¤´çª—å£ */
        #webcam-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            opacity: 0.8;
            transform: scaleX(-1);
            z-index: 20;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transition: opacity 0.5s ease;
        }
        #webcam-feed.hidden { opacity: 0; pointer-events: none; }

        /* äº¤äº’æŒ‰é’®åŒºåŸŸ */
        .controls {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: absolute;
            bottom: 40px;
            left: 40px;
        }

        button, .file-upload {
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 12px 28px;
            font-size: 1rem;
            cursor: pointer;
            transition: 0.3s;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
            text-align: center;
            border-radius: 4px;
        }

        button:hover, .file-upload:hover {
            background: var(--gold);
            color: #1a1a1a;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
            font-weight: bold;
        }

        input[type="file"] { display: none; }

        /* é¡¶éƒ¨æŒ‰é’®æ ·å¼ */
        .top-btn {
            padding: 8px 15px;
            font-size: 0.9rem;
            border-radius: 20px;
            cursor: pointer;
            border: 1px solid #555;
            transition: all 0.3s;
            background: rgba(0,0,0,0.3);
            color: #ccc;
        }
        .top-btn:hover {
            border-color: var(--gold);
            color: var(--gold);
        }

        #btn-music.playing {
            border-color: var(--gold);
            color: var(--gold);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0c101c;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 1s ease;
        }

        .loader-text {
            color: var(--gold);
            margin-top: 20px;
            letter-spacing: 3px;
            font-size: 1.2rem;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,215,0,0.3);
            border-top-color: var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* æ‹–æ‹½ä¸Šä¼ æç¤ºå±‚ */
        #drop-zone {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 215, 0, 0.2);
            border: 5px dashed var(--gold);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: #fff;
            pointer-events: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* å³ä¾§æ“ä½œè¯´æ˜ */
        .instruction-box {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.4);
            padding: 25px;
            border-left: 3px solid var(--gold);
            color: #eee;
            font-size: 0.95rem;
            line-height: 1.8;
            border-radius: 0 10px 10px 0;
            backdrop-filter: blur(5px);
        }
        .instruction-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        .icon { font-size: 1.6rem; margin-right: 12px; width: 30px; text-align: center; }

    </style>
</head>
<body>
    <!-- åœ£è¯å¿«ä¹å¤§å­— -->
    <div id="merry-christmas">Merry Christmas</div>

    <!-- æ‹–æ‹½æç¤º -->
    <div id="drop-zone">æ¾æ‰‹å³å¯æ·»åŠ ç…§ç‰‡ ğŸ“¸</div>

    <!-- é¡¶éƒ¨æŒ‰é’®ç»„ (åŒ…å«éŸ³ä¹) -->
    <div style="position: absolute; top: 20px; right: 20px; z-index: 100; display: flex; gap: 10px;">
        <button id="btn-music" class="top-btn">ğŸµ æ’­æ”¾éŸ³ä¹</button>
        <button id="btn-toggle-ui" class="top-btn">ğŸ‘ï¸ éšè— UI</button>
    </div>

    <!-- éšè—çš„éŸ³é¢‘å…ƒç´  -->
    <audio id="bgm" loop></audio>

    <!-- UI Layer -->
    <div id="ui-layer">
        <!-- ç§»åˆ°å·¦ä¾§çš„ Header -->
        <div class="header">
            <h1>åœ£è¯é­”æ³•æ ‘</h1>
            <div class="status-bar">
                <div id="state-tree" class="status-badge active">åœ£è¯æ ‘æ¨¡å¼</div>
                <div id="state-scatter" class="status-badge">æ˜Ÿäº‘æ¼«æ¸¸</div>
                <div id="state-focus" class="status-badge">ç…§ç‰‡å›å¿†</div>
            </div>
        </div>

        <div class="instruction-box">
            <div class="instruction-item"><span class="icon">âœŠ</span> <strong>æ¡æ‹³</strong>ï¼šèšåˆä¸ºåœ£è¯æ ‘</div>
            <div class="instruction-item"><span class="icon">âœ‹</span> <strong>äº”æŒ‡å¼ å¼€</strong>ï¼šç‚¸å¼€æˆæ˜Ÿäº‘</div>
            <div class="instruction-item"><span class="icon">ğŸ‘‹</span> <strong>æ‰‹æŒç§»åŠ¨</strong>ï¼šæ—‹è½¬è§†è§’</div>
            <div class="instruction-item"><span class="icon">ğŸ‘Œ</span> <strong>æåˆ</strong>ï¼šæŠ“å–éšæœºç…§ç‰‡</div>
        </div>

        <div class="controls">
            <button id="btn-start">å¼€å¯æ‘„åƒå¤´äº’åŠ¨</button>
            <label class="file-upload">
                ä¸Šä¼ ç…§ç‰‡ / æ‹–å…¥ç…§ç‰‡
                <input type="file" id="photo-input" multiple accept="image/*">
            </label>
            <!-- éŸ³ä¹ä¸Šä¼ æŒ‰é’® -->
            <label class="file-upload" style="margin-top: -10px; font-size: 0.8rem; padding: 8px;">
                ğŸµ æ›´æ¢èƒŒæ™¯éŸ³ä¹
                <input type="file" id="music-input" accept="audio/*">
            </label>
        </div>
    </div>

    <video id="webcam-feed" playsinline></video>
    <div id="canvas-container"></div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // æœ¬åœ°å›¾ç‰‡å°è¯•åˆ—è¡¨
        const LOCAL_IMAGES_TO_TRY = [
            '1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg',
            '1.png', '2.png', '3.png', '4.png', '5.png'
        ];

        const CONFIG = {
            particleCount: 3500,
            snowCount: 650,
            treeHeight: 40,
            treeRadius: 15,
            colors: {
                green: 0x2F5A35,
                gold: 0xFFD700,
                red: 0xB00B0B
            },
            cameraZ: 65
        };

        let state = {
            mode: 'TREE',
            targetRotation: { x: 0, y: 0 },
            handPresent: false,
            pinching: false,
            focusedPhotoIndex: -1,
            uiHidden: false
        };

        let scene, camera, renderer, composer;
        let particles = [];
        let dummy = new THREE.Object3D();
        let instancedMesh;
        let snowSystem;
        let photoMeshes = [];
        let clock = new THREE.Clock();
        let topStarMesh;

        // å°è¯•åŠ è½½æœ¬åœ°å›¾ç‰‡
        function loadLocalPhotos() {
            const loader = new THREE.TextureLoader();
            let successCount = 0;
            LOCAL_IMAGES_TO_TRY.forEach(name => {
                loader.load(name, (tex) => {
                    successCount++;
                    tex.colorSpace = THREE.SRGBColorSpace;
                    createPhotoMeshFromTexture(tex);

                    if(state.mode === 'TREE') {
                        state.mode = 'SCATTER';
                        updateUI();
                    }
                }, undefined, (err) => {
                    // å¿½ç•¥åŠ è½½é”™è¯¯
                });
            });

            setTimeout(() => {
                if (successCount === 0 && photoMeshes.length === 0) {
                    console.log("æœªæ£€æµ‹åˆ°æœ¬åœ°å›¾ç‰‡æˆ–æµè§ˆå™¨é˜»æ­¢äº†è¯»å–ã€‚è¯·ä½¿ç”¨æ‰‹åŠ¨ä¸Šä¼ ã€‚");
                }
            }, 2000);
        }

        // éŸ³ä¹åˆå§‹åŒ–é€»è¾‘
        function initMusic() {
            const bgm = document.getElementById('bgm');
            const btnMusic = document.getElementById('btn-music');
            const musicInput = document.getElementById('music-input');

            bgm.src = 'music.mp3';

            btnMusic.addEventListener('click', () => {
                if (bgm.paused) {
                    bgm.play().then(() => {
                        btnMusic.textContent = "â¸ï¸ æš‚åœéŸ³ä¹";
                        btnMusic.classList.add('playing');
                    }).catch(e => {
                        alert("æ— æ³•æ’­æ”¾éŸ³ä¹ï¼šè¯·ç¡®ä¿æ–‡ä»¶å¤¹å†…æœ‰ 'music.mp3' æˆ–ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®ä¸Šä¼ éŸ³ä¹æ–‡ä»¶ã€‚");
                        console.warn(e);
                    });
                } else {
                    bgm.pause();
                    btnMusic.textContent = "ğŸµ æ’­æ”¾éŸ³ä¹";
                    btnMusic.classList.remove('playing');
                }
            });

            musicInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    bgm.src = url;
                    bgm.play();
                    btnMusic.textContent = "â¸ï¸ æš‚åœéŸ³ä¹";
                    btnMusic.classList.add('playing');
                }
            });
        }

        const init = () => {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0c101c, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.cameraZ;
            camera.position.y = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            // --- ç¯å…‰è®¾ç½® ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
            scene.add(ambientLight);

            const innerLight = new THREE.PointLight(0xffaa00, 400, 40);
            innerLight.position.set(0, 10, 0);
            scene.add(innerLight);

            const lowerInnerLight = new THREE.PointLight(0xffaa00, 400, 40);
            lowerInnerLight.position.set(0, -10, 0);
            scene.add(lowerInnerLight);

            const spotLight = new THREE.SpotLight(0xffd700, 100);
            spotLight.position.set(20, 50, 20);
            spotLight.angle = 0.6;
            spotLight.penumbra = 0.5;
            scene.add(spotLight);

            const hemiLight = new THREE.HemisphereLight(0x444444, 0x000000, 0.6);
            scene.add(hemiLight);

            createTopStar();

            // --- åå¤„ç† ---
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.8;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticles();
            createSnow();

            loadLocalPhotos();
            initMusic();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('photo-input').addEventListener('change', handlePhotoUpload);
            document.getElementById('btn-toggle-ui').addEventListener('click', toggleUI);

            setupDragAndDrop();

            setTimeout(() => {
                const loadingEl = document.getElementById('loading');
                if (loadingEl) {
                    loadingEl.style.opacity = '0';
                    setTimeout(() => {
                        if (loadingEl) loadingEl.remove();
                    }, 1000);
                }
            }, 1000);

            animate();
        };

        // --- æ‹–æ‹½ä¸Šä¼ æ”¯æŒ ---
        function setupDragAndDrop() {
            const dropZone = document.getElementById('drop-zone');

            window.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.style.display = 'flex';
            });

            window.addEventListener('dragleave', (e) => {
                if (e.clientX === 0 || e.clientY === 0) {
                    dropZone.style.display = 'none';
                }
            });

            window.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.display = 'none';

                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    processFiles(e.dataTransfer.files);
                }
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.style.display = 'none';
            });
        }

        function createTopStar() {
            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = 3.5;
            const innerRadius = 1.75;

            for (let i = 0; i < points * 2; i++) {
                const angle = (i / (points * 2)) * Math.PI * 2 + Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();

            const extrudeSettings = {
                steps: 1,
                depth: 1.5,
                bevelEnabled: true,
                bevelThickness: 1.5,
                bevelSize: 1.0,
                bevelSegments: 10
            };

            const starGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            starGeo.center();

            const starMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.gold,
                emissive: CONFIG.colors.gold,
                emissiveIntensity: 1.5,
                roughness: 0.1,
                metalness: 1.0
            });

            topStarMesh = new THREE.Mesh(starGeo, starMat);
            topStarMesh.position.set(0, CONFIG.treeHeight / 2 + 3, 0);
            scene.add(topStarMesh);

            const starPointLight = new THREE.PointLight(CONFIG.colors.gold, 0.5, 30);
            starPointLight.position.copy(topStarMesh.position);
            scene.add(starPointLight);
        }

        function toggleUI() {
            state.uiHidden = !state.uiHidden;
            const uiLayer = document.getElementById('ui-layer');
            const webcam = document.getElementById('webcam-feed');
            const title = document.getElementById('merry-christmas');
            const btn = document.getElementById('btn-toggle-ui');
            const btnMusic = document.getElementById('btn-music');

            if (state.uiHidden) {
                uiLayer.classList.add('hidden');
                webcam.classList.add('hidden');
                title.classList.add('hidden');
                btn.textContent = 'ğŸ‘ï¸ æ˜¾ç¤º UI';
                btnMusic.style.display = 'none';
            } else {
                uiLayer.classList.remove('hidden');
                webcam.classList.remove('hidden');
                title.classList.remove('hidden');
                btn.textContent = 'ğŸ‘ï¸ éšè— UI';
                btnMusic.style.display = 'block';
            }
        }

        function createSnow() {
            const snowGeo = new THREE.BufferGeometry();
            const snowPos = [];
            const snowVel = [];

            for(let i=0; i<CONFIG.snowCount; i++) {
                const x = (Math.random() - 0.5) * 100;
                const y = Math.random() * 80 + 20;
                const z = (Math.random() - 0.5) * 80;
                snowPos.push(x, y, z);
                snowVel.push((Math.random() * 0.1) + 0.05);
            }

            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));

            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(16,16,0,16,16,16);
            grd.addColorStop(0, 'rgba(255,255,255,1)');
            grd.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0,0,32,32);

            const texture = new THREE.CanvasTexture(canvas);

            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                map: texture,
                transparent: true,
                opacity: 0.6,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            snowSystem = new THREE.Points(snowGeo, snowMat);
            snowSystem.userData = { velocities: snowVel };
            scene.add(snowSystem);
        }

        function updateSnow() {
            if(!snowSystem) return;
            const positions = snowSystem.geometry.attributes.position.array;
            const velocities = snowSystem.userData.velocities;

            for(let i=0; i<CONFIG.snowCount; i++) {
                positions[i*3 + 1] -= velocities[i];
                positions[i*3] += Math.sin(clock.getElapsedTime() + i) * 0.02;

                if(positions[i*3 + 1] < -30) {
                    positions[i*3 + 1] = 60;
                    positions[i*3] = (Math.random() - 0.5) * 100;
                    positions[i*3 + 2] = (Math.random() - 0.5) * 80;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        function getRandomSpherePoint(radius) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(Math.random()) * radius;
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        function createParticles() {
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);

            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.0,
                metalness: 1.0,
                transparent: true,
                opacity: 1.0
            });

            instancedMesh = new THREE.InstancedMesh(geometry, material, CONFIG.particleCount);
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(instancedMesh);

            const baseColors = [
                new THREE.Color(CONFIG.colors.green),
                new THREE.Color(CONFIG.colors.gold),
                new THREE.Color(CONFIG.colors.red),
                new THREE.Color(0xffffff)
            ];

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const t = i / CONFIG.particleCount;
                let type = 'leaf';

                if (t > 0.9) {
                    type = 'leaf';
                } else if (t < 0.5) {
                    if (i % 4 === 0) {
                        type = 'ornament';
                    } else {
                        type = Math.random() > 0.95 ? 'ornament' : 'leaf';
                    }
                } else {
                    type = Math.random() > 0.85 ? 'ornament' : 'leaf';
                }

                const angle = t * Math.PI * 22;
                const height = t * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
                const radius = (1 - t) * CONFIG.treeRadius;
                const treePos = new THREE.Vector3(
                    Math.cos(angle) * radius + (Math.random()-0.5)*2,
                    height,
                    Math.sin(angle) * radius + (Math.random()-0.5)*2
                );

                const scatterPos = getRandomSpherePoint(45);

                let color;
                if(type === 'ornament') {
                     if(Math.random() > 0.5) {
                        color = baseColors[1].clone();
                        color.multiplyScalar(10.0);
                     } else {
                        color = baseColors[2].clone().multiplyScalar(2.0);
                     }
                } else {
                     if(Math.random() > 0.92) {
                        color = baseColors[3].clone();
                        color.multiplyScalar(10.0);
                     } else {
                        color = baseColors[0].clone().multiplyScalar(1.5);
                     }
                }

                instancedMesh.setColorAt(i, color);

                const scale = Math.random() * 0.6 + 0.4;

                particles.push({
                    id: i,
                    currentPos: treePos.clone(),
                    treePos: treePos,
                    scatterPos: scatterPos,
                    scale: new THREE.Vector3(scale, scale, scale),
                    phase: Math.random() * Math.PI * 2
                });

                dummy.position.copy(treePos);
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
            instancedMesh.instanceColor.needsUpdate = true;
        }

        // [ä¿®æ”¹] åˆ›å»ºç…§ç‰‡é€»è¾‘ï¼šæè´¨è®¾ç½®ä¼˜åŒ–
        function createPhotoMeshFromTexture(texture) {
            const img = texture.image;
            if (!img || !img.width || !img.height) return;

            const aspect = img.width / img.height;
            const photoWidth = 4;
            const photoHeight = photoWidth / aspect;

            texture.repeat.set(0.8, 0.8);
            texture.offset.set(0.1, 0.15);

            const photoGroup = new THREE.Group();

            const borderGeo = new THREE.PlaneGeometry(photoWidth + 0.6, photoHeight + 1.5);
            // [ä¿®æ”¹] ç™½è¾¹æ¡†ï¼šç²—ç³™åº¦1.0 (å“‘å…‰çº¸)ï¼Œè‡ªå‘å…‰0.1 (å¾®å…‰)
            const borderMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                roughness: 1.0,       // å®Œå…¨ç²—ç³™
                metalness: 0.0,
                emissive: 0xffffff,
                emissiveIntensity: 0.1 // å¾®å¼±è‡ªå‘å…‰
            });
            const borderMesh = new THREE.Mesh(borderGeo, borderMat);
            borderMesh.position.y = -0.4;
            photoGroup.add(borderMesh);

            const photoGeo = new THREE.PlaneGeometry(photoWidth, photoHeight);

            const photoMat = new THREE.MeshStandardMaterial({
                map: texture,
                emissive: 0xffffff,
                emissiveIntensity: 0.05,
                side: THREE.DoubleSide,
                transparent: true,
                roughness: 0.8,
                metalness: 0.0
            });
            const photoMesh = new THREE.Mesh(photoGeo, photoMat);
            photoMesh.position.z = 0.01;
            photoGroup.add(photoMesh);

            // æ··åˆåˆ†å¸ƒ
            const scatterPos = getRandomSpherePoint(45);

            photoGroup.userData = {
                scatterPos: scatterPos,
                treePos: new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 30,
                    10 + (Math.random() * 5)
                )
            };

            photoGroup.position.copy(photoGroup.userData.scatterPos);
            photoGroup.scale.set(0,0,0);

            scene.add(photoGroup);
            photoMeshes.push(photoGroup);
        }

        function processFiles(files) {
            Array.from(files).forEach((file) => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.src = e.target.result;
                        img.onload = () => {
                            const texture = new THREE.Texture(img);
                            texture.colorSpace = THREE.SRGBColorSpace;
                            texture.needsUpdate = true;
                            createPhotoMeshFromTexture(texture);
                            state.mode = 'SCATTER';
                            updateUI();
                        };
                    };
                    reader.readAsDataURL(file);
                } else if (file.type.startsWith('audio/')) {
                    const url = URL.createObjectURL(file);
                    const bgm = document.getElementById('bgm');
                    const btnMusic = document.getElementById('btn-music');
                    bgm.src = url;
                    bgm.play();
                    btnMusic.textContent = "â¸ï¸ æš‚åœéŸ³ä¹";
                    btnMusic.classList.add('playing');
                }
            });
        }

        function handlePhotoUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            processFiles(files);
        }

        const _tempTarget = new THREE.Vector3();
        const _tempVec = new THREE.Vector3();
        const _tempLook = new THREE.Vector3();
        const _tempPush = new THREE.Vector3();
        const _tempFocus = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            updateSnow();

            if (topStarMesh) {
                topStarMesh.rotation.y = time * 0.5;
            }

            if (instancedMesh && instancedMesh.material) {
                const targetOpacity = state.mode === 'TREE' ? 1.0 : 0.3;
                instancedMesh.material.opacity = THREE.MathUtils.lerp(instancedMesh.material.opacity, targetOpacity, 0.05);
            }

            if (state.mode === 'SCATTER' && state.handPresent) {
                const targetX = state.targetRotation.x * -50;
                const targetY = state.targetRotation.y * -30 + 10;

                camera.position.x += (targetX - camera.position.x) * 0.05;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            } else if (state.mode === 'TREE') {
                const radius = 60;
                camera.position.x = Math.sin(time * 0.15) * radius;
                camera.position.z = Math.cos(time * 0.15) * radius;

                camera.position.y += (5 - camera.position.y) * 0.05;
                camera.lookAt(0, 8, 0);
            } else if (state.mode === 'FOCUS') {
                camera.position.lerp(new THREE.Vector3(0, 0, 45), 0.05);
                camera.lookAt(0,0,0);
            }

            // [æ–°å¢] ç²’å­é¿è®©é€»è¾‘ï¼šåœ¨ FOCUS æ¨¡å¼ä¸‹æ¨å¼€æŒ¡ä½è§†çº¿çš„ç²’å­
            let camPos = camera.position;

            // é»˜è®¤ä¸­å¿ƒ
            _tempFocus.set(0, 0, 0);
            // å¦‚æœæœ‰é€‰ä¸­ç…§ç‰‡ï¼Œç›®æ ‡ç‚¹æ˜¯ç…§ç‰‡ä½ç½® (Z=25é™„è¿‘)
            if (state.mode === 'FOCUS') _tempFocus.set(0, 0, 25);

            // è®¡ç®—è§†çº¿æ–¹å‘ (å¤ç”¨ _tempLook)
            _tempLook.subVectors(_tempFocus, camPos).normalize();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const p = particles[i];

                if (state.mode === 'TREE') {
                    _tempTarget.copy(p.treePos);
                } else {
                    _tempTarget.copy(p.scatterPos);

                    // 1. åŸºç¡€æµ®åŠ¨
                    _tempTarget.y += Math.sin(time + p.phase) * 1.5;

                    // 2. [å…³é”®] é¿è®©è®¡ç®—
                    if (state.mode === 'FOCUS') {
                        // è®¡ç®—ç²’å­åˆ°è§†çº¿çš„å‚ç›´è·ç¦» (å¤ç”¨ _tempVec)
                        _tempVec.subVectors(_tempTarget, camPos);
                        let projection = _tempVec.dot(_tempLook);

                        // åªå¤„ç†ä½äºç›¸æœºå‰æ–¹ä¸”æ²¡è¶…è¿‡ç…§ç‰‡å¤ªè¿œçš„ç²’å­
                        if (projection > 5 && projection < 60) {
                            // closestPointOnLine = camPos + lookVec * projection
                            // ä½¿ç”¨ _tempPush æš‚å­˜ closestPointOnLine
                            _tempPush.copy(_tempLook).multiplyScalar(projection).add(camPos);

                            // distToLine
                            let distToLine = _tempTarget.distanceTo(_tempPush);

                            // [ä¿®æ”¹] å¼ºåŠ›æ’æ–¥ï¼šåŠå¾„æ‰©å¤§åˆ° 25ï¼Œç³»æ•°å¢å¼ºåˆ° 2.5
                            if (distToLine < 25) {
                                // è®¡ç®—æ¨å¼€æ–¹å‘ (ä»çº¿ä¸­å¿ƒå‘å¤–) -> å¤ç”¨ _tempVec
                                _tempVec.subVectors(_tempTarget, _tempPush).normalize();

                                // å¦‚æœé‡åˆï¼Œç»™ä¸ªéšæœºæ–¹å‘
                                if (_tempVec.lengthSq() === 0) _tempVec.set(1, 0, 0);

                                // æ¨å¼€åŠ›åº¦ï¼šè¶Šé è¿‘ä¸­å¿ƒæ¨å¾—è¶Šè¿œ
                                let pushDist = (25 - distToLine) * 2.5;
                                _tempTarget.add(_tempVec.multiplyScalar(pushDist));
                            }
                        }
                    }
                }

                p.currentPos.lerp(_tempTarget, 0.04);

                dummy.position.copy(p.currentPos);
                dummy.rotation.set(time * 0.5 + p.phase, time * 0.3, 0);
                dummy.scale.copy(p.scale);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            instancedMesh.instanceMatrix.needsUpdate = true;

            photoMeshes.forEach((mesh, index) => {
                let targetPos, targetScale, targetRot;

                if (state.mode === 'TREE') {
                    targetPos = mesh.userData.treePos;
                    targetScale = 0.01;
                    targetRot = new THREE.Euler(0, time, 0);
                } else if (state.mode === 'SCATTER') {
                    targetPos = mesh.userData.scatterPos.clone();
                    // å›¢çŠ¶æ˜Ÿäº‘æ—¶ç…§ç‰‡çš„æµ®åŠ¨
                    targetPos.y += Math.sin(time + index) * 1.0;
                    targetScale = 1;
                    targetRot = new THREE.Euler(
                        Math.sin(time * 0.2 + index) * 0.2,
                        Math.cos(time * 0.3 + index) * 0.2,
                        Math.sin(time * 0.1 + index)*0.1
                    );
                } else if (state.mode === 'FOCUS') {
                    if (index === state.focusedPhotoIndex) {
                        // [ä¿®æ”¹] æŠ“å–ä½ç½®ï¼šå›åˆ° Z=25 (æ­£å¸¸è·ç¦»)ï¼Œä¸è´´è„¸
                        targetPos = new THREE.Vector3(0, 0, 25);
                        targetScale = 3.5;
                        targetRot = new THREE.Euler(0, 0, 0);
                    } else {
                        targetPos = mesh.userData.scatterPos.clone().multiplyScalar(1.5);
                        targetScale = 0.3;
                        targetRot = new THREE.Euler(0,0,0);
                    }
                }

                mesh.position.lerp(targetPos, 0.06);
                const s = THREE.MathUtils.lerp(mesh.scale.x, targetScale, 0.06);
                mesh.scale.set(s,s,s);
                mesh.rotation.x = THREE.MathUtils.lerp(mesh.rotation.x, targetRot.x, 0.06);
                mesh.rotation.y = THREE.MathUtils.lerp(mesh.rotation.y, targetRot.y, 0.06);
                mesh.rotation.z = THREE.MathUtils.lerp(mesh.rotation.z, targetRot.z, 0.06);
            });

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateUI() {
            document.querySelectorAll('.status-badge').forEach(el => el.classList.remove('active'));
            if(state.mode === 'TREE') document.getElementById('state-tree').classList.add('active');
            if(state.mode === 'SCATTER') document.getElementById('state-scatter').classList.add('active');
            if(state.mode === 'FOCUS') document.getElementById('state-focus').classList.add('active');
        }

        const videoElement = document.getElementById('webcam-feed');
        let hands;

        document.getElementById('btn-start').addEventListener('click', async () => {
            document.getElementById('btn-start').style.display = 'none';
            setupMediaPipe();
        });

        async function setupMediaPipe() {
            if (!window.Hands) {
                alert("ç»„ä»¶åŠ è½½ä¸­ï¼Œè¯·ç¨åé‡è¯•...");
                document.getElementById('btn-start').style.display = 'block';
                return;
            }

            hands = new window.Hands({locateFile: (file) => {
                return `https://unpkg.com/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandResults);

            const camera = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            camera.start();
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handPresent = true;
                const landmarks = results.multiHandLandmarks[0];

                state.targetRotation.x = (landmarks[9].x - 0.5) * -2;
                state.targetRotation.y = -(landmarks[9].y - 0.5) * 2;

                detectGesture(landmarks);
            } else {
                state.handPresent = false;
            }
        }

        function detectGesture(landmarks) {
            const isOpen = isHandOpen(landmarks);
            const isFist = isHandFist(landmarks);
            const isPinch = isHandPinch(landmarks);

            if (isFist) {
                if (state.mode !== 'TREE') {
                    state.mode = 'TREE';
                    state.focusedPhotoIndex = -1;
                    updateUI();
                }
            } else if (isPinch) {
                if (!state.pinching) {
                    state.pinching = true;
                    state.mode = 'FOCUS';

                    if (photoMeshes.length > 0) {
                        let next = Math.floor(Math.random() * photoMeshes.length);
                        if(next === state.focusedPhotoIndex) next = (next + 1) % photoMeshes.length;
                        state.focusedPhotoIndex = next;
                    }
                    updateUI();
                }
            } else if (isOpen) {
                state.pinching = false;
                if (state.mode === 'TREE' || state.mode === 'FOCUS') {
                    state.mode = 'SCATTER';
                    state.focusedPhotoIndex = -1;
                    updateUI();
                }
            } else {
                state.pinching = false;
            }
        }

        function isHandOpen(landmarks) {
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let extendedCount = 0;
            tips.forEach((tipIdx, i) => {
                if (dist(wrist, landmarks[tipIdx]) > dist(wrist, landmarks[pips[i]]) * 1.2) extendedCount++;
            });
            return extendedCount >= 4;
        }

        function isHandFist(landmarks) {
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let curledCount = 0;
            tips.forEach((tipIdx, i) => {
                if (dist(wrist, landmarks[tipIdx]) < dist(wrist, landmarks[pips[i]])) curledCount++;
            });
            return curledCount >= 4;
        }

        function isHandPinch(landmarks) {
            return dist(landmarks[4], landmarks[8]) < 0.05;
        }

        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        init();

    </script>
</body>
</html>